#version 450

#extension GL_GOOGLE_include_directive : enable
#include "LightCullSettings.h"

shared int lightList[MAX_LIGHTS];

layout (std140, set = 0, binding = 0) uniform Scene
{
    mat4 view;
    mat4 projection;
    float near;
    float far;
    uint screenWidth;
    uint screenHeight;
} scene;

struct Light
{
    vec3 position;
    float radius;
};

layout (set = 0, binding = 1) uniform LightInfo
{
    Light lights[MAX_LIGHTS];
    uint numLights;
}lightInfo;

struct Cluster
{
    vec4 minPos;
    vec4 maxPos;
    uint lightIds[MAX_LIGHTS_PER_CLUSTER];
    uint numLights;
};

layout(set = 0, binding = 2) buffer ClusterInfo
{
    Cluster cluster[CLUSTER_X * CLUSTER_Y * CLUSTER_Z];
}clusterInfo;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

/*
bool IsLightInCluster(AABB lightAabb, AABB clusterAabb)
{
    if(
    lightAabb.minPos.x <= clusterAabb.maxPos.x &&
    lightAabb.maxPos.x >= clusterAabb.minPos.x &&
    lightAabb.minPos.y <= clusterAabb.maxPos.y &&
    lightAabb.maxPos.y >= clusterAabb.minPos.y &&
    lightAabb.minPos.z <= clusterAabb.maxPos.z &&
    lightAabb.maxPos.z >= clusterAabb.minPos.z
    )
    {
        return true;
    }
    return false;
}
*/

bool IsPointLightInCluster(vec3 center, float radius, vec3 minPos, vec3 maxPos)
{
    vec3 centerVS = (scene.view * vec4(center, 1.0)).xyz;
    // find the closest AABB point to the center
    float x = max(minPos.x, min(centerVS.x, maxPos.x));
    float y = max(minPos.y, min(centerVS.y, maxPos.y));
    float z = max(minPos.z, min(centerVS.z, maxPos.z));

    float distanceValue = distance(vec3(x, y, z) , centerVS);

    return distanceValue < radius;
}

void main() 
{
    uint clusterIndex = 
          gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y +
          gl_WorkGroupID.y * gl_NumWorkGroups.x + 
          gl_WorkGroupID.x;

    uint lightIndex = gl_LocalInvocationIndex;

    if(lightIndex == 0)
    {
        for(uint i = 0 ; i < MAX_LIGHTS; i++)
        {
            lightList[i] = -1;
        }
    }

    memoryBarrierShared();
    barrier();

    if( lightIndex < lightInfo.numLights )
    {
        vec3 lightPositionWs = lightInfo.lights[lightIndex].position;
        float lightRadius =  lightInfo.lights[lightIndex].radius;
        vec3 clusterMinPos = clusterInfo.cluster[clusterIndex].minPos.xyz;
        vec3 clusterMaxPos = clusterInfo.cluster[clusterIndex].maxPos.xyz;
        if(IsPointLightInCluster(lightPositionWs, lightRadius, clusterMinPos, clusterMaxPos))
        {
            lightList[lightIndex] = 1;
        }
    }

    memoryBarrierShared();
    barrier();

    if(lightIndex == 0)
    {
        uint counter = 0;
        for(uint i = 0 ; i < MAX_LIGHTS; i++)
        {
            if(counter >= MAX_LIGHTS_PER_CLUSTER)
                break;
            if(lightList[i] == 1)
            {
                clusterInfo.cluster[clusterIndex].lightIds[counter++] = i;
                clusterInfo.cluster[clusterIndex].numLights = counter;
            }
        }
    }
}